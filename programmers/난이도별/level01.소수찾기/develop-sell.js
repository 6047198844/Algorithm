// 내 코드 
function solution(n) {
  let answer = 0;
  for(let i = 2; i <= n; i++){
      let isPrime = true;
      if (i === 2){
          answer ++;
          continue;
      }
      if (i === 3){
          answer ++;
          continue;
      }
      if (i % 2 === 0){
          continue;
      }
      for(let j = 2; j < i/2; j++){
          if(i % j === 0){ 
              isPrime = false;
              break;
          }
      }
      if (isPrime === true)
          answer++;
  }
  return answer;
}

// 소수찾기 생각보다 쉬워보여서 도전했다가 생각보다 오랜 시간이 걸렸다
// 소수찾는 로직은 쉬웠지만, 효율성에서 문제가 발생했다.
// 소수찾는 로직(처음) : 이중 for문으로 2~ n-1 수까지 n을 나눠보고 만약 값이 딱 맞게 나눠지면(i % j == 0) 그 수는 소수가 아닌 것이다.

// 1차 효율성 고려 : 자신 수의 절반 숫자로까지만 나누자. (ex. 14의 경우 절반인 7까지만 나눠보면 소수인지 아닌지 판단할 수 있다.)
// i / 2 까지만 확인 

// 2차 효율성 고려 : 자신 수+1 의 루트만큼만 나누자. 
// Math.sqrt(i+1) 까지만 확인

// 3차 효율성 고려 : 2의 배수는 다 제거하자 
// 앞에 2로 나눠서 0이 되는 경우는 다 제거해주자 

// 이렇게 총 3번 도전을 했는데, 마지막 4개의 효율성에선 문제가 계속 있어서 계속 고려하다가 eyabc님의 코드를 보고 이해하는 것으로 공부했다.
// 출처 : eyabc.js

// 아이디어는 위에 2로 나눠서 0이 되는 경우뿐만 아니라 
// 3,5 등 계속 소수면 그에 해당되는 배수들을 접근할때 바로 소수가 아니라고 지칭하는 것이다. (false -> true)
// 그렇게 되면 현저히 나누는 값들의 개수가 줄어들게 된다.
// ex. 11을 확인할때는 이미 1,2,3 ... 10까지 할 때 2,3,5,7들의 배수들인 4,6,8,10 / 3,6,9 / 5,10 은 이미 true 값이라 
// 비교를 안하고 continue문으로 빠져나간다.
// 그렇게 되면 이 경우엔 1,2,3,4,5,6,7,8,9,10까지 모든 숫자가 비교를 안해도 되고 바로 소수임을 인정하고 이에 해당되는 모든 배수를 또 소수로 만드는 식이다.

// 배수를 true로 바꿔주는 식 (i+i , j = j + i) 이 식이 헷갈렸다
for (let j = i + i ; j < N ; j += i) {
  primeTable[j] = true;
}

// 생각보다 비교하는 식이 오래걸린다. 
// 제외할 조건들은 continue로 최대한 빼주고 
// for문 도는 횟수를 줄이는 것이 목표다. (for문 한번 돌 때 status를 바꿔주는 식 )