const { strict } = require("assert");

//1번째 풀이 
function solution(n)
{
    let answer = 0;
    (n + '').split('').forEach((num)=>{
        answer += num * 1
    })
    return answer;
}

// 문제풀이: 
// 문제의 핵심은 형변환이다. 
// 숫자인 n을 자동형변환으로 string으로 만들고,
// 각 char를 다시 자동형변환으로 숫자로 바꿔서 answer에 다 더한다. 
// string -> array 로 변환 후 forEach문으로 더함 

//2번째 풀이 
function solution(n)
{
    let answer = 0;
    n = n + '';
    let len = n.length
    for(let i = 0; i < len; i++){
        answer += n[i] * 1
    }

    return answer;
}
// 문제풀이: 
// string 그대로 for문을 통해 값을 더함

// 궁금한점: 
// 과연 저렇게 string에서 for문으로 접근하는 방법이 좋은가? #2번 방법
// 아님 split으로 배열로 char별로 나누고 forEach문으로 접근하는게 좋은가? #1번 방법

// 프로그래머스 풀이
return (n+"").split("").reduce((acc, curr) => acc + parseInt(curr), 0)

// reduce 함수의 역할
// forEach : 배열의 요소를 접근하는 기능으로만 사용. 반복문 외부에 값을 조정할 때 유용. (ex. let answer 에 배열의 요소 값을 다 더해줄 때)
// map: 리턴값의 배열 길이는 동일하나 배열 각각의 요소를 바꾸고 싶을 때 사용. (조건에 따라 char가 될수도, str이 될수도, 값이 더해질 수도 있는 것)
// filter: 리턴값의 배열 길이가 다르다. 해당되는 요소만 filter하는 것. (이때 값을 바꾸면서도 return 가능)
// reduce: 배열의 각 요소가 리듀서(reducer) 함수를 실행하고 하나의 값을 반환. 누산기가 존재한다. (함수의 값을 누적하는 기기?)
//  return array.reduce((acc, curr) => acc + parseInt(curr), 0)
//  여기서 acc는 지금까지 누적된 값이고, curr는 현재 배열의 요소이다. 마지막의 0은 초기값을 말함. 초기 acc 값. 
//  ex. ['1','2','3'] 
//  [0] acc: 0 , curr: '1'
//  [1] acc: 1 , curr: '2'
//  [2] acc: 3 , curr: '3'
//  return 값은 6 


 

// 배운점: 
// *자동형변환
//  숫자에서 문자열 : + '' 하면 된다. ex. 3424 + '' => '3424' 로 변환
//  문자열에서 숫자 : * 1 하면 된다. ex. '3424' * 1 => 3424 로 변환



// #1 풀이의 결과
// 테스트 1 〉	통과 (0.11ms, 30.1MB)
// 테스트 2 〉	통과 (0.06ms, 30.2MB)
// 테스트 3 〉	통과 (0.07ms, 30.3MB)
// 테스트 4 〉	통과 (0.07ms, 30.1MB)
// 테스트 5 〉	통과 (0.07ms, 29.7MB)
// 테스트 6 〉	통과 (0.06ms, 30.1MB)
// 테스트 7 〉	통과 (0.05ms, 30.2MB)
// 테스트 8 〉	통과 (0.07ms, 30.1MB)
// 테스트 9 〉	통과 (0.07ms, 30MB)
// 테스트 10 〉	통과 (0.06ms, 30MB)
// 테스트 11 〉	통과 (0.07ms, 30MB)
// 테스트 12 〉	통과 (0.07ms, 30.1MB)
// 테스트 13 〉	통과 (0.07ms, 30MB)
// 테스트 14 〉	통과 (0.07ms, 30MB)
// 테스트 15 〉	통과 (0.07ms, 30.2MB)
// 테스트 16 〉	통과 (0.07ms, 30.1MB)
// 테스트 17 〉	통과 (0.07ms, 30MB)
// 테스트 18 〉	통과 (0.09ms, 30MB)
// 테스트 19 〉	통과 (0.07ms, 30.1MB)
// 테스트 20 〉	통과 (0.05ms, 30.1MB)
// 테스트 21 〉	통과 (0.06ms, 30.2MB)

// #2 풀이의 결과
// 테스트 1 > 통과 (0.06ms, 30MB)
// 테스트 2 〉	통과 (0.06ms, 30.1MB)
// 테스트 3 〉	통과 (0.05ms, 30.1MB)
// 테스트 4 〉	통과 (0.04ms, 30MB)
// 테스트 5 〉	통과 (0.06ms, 30MB)
// 테스트 6 〉	통과 (0.06ms, 30.3MB)
// 테스트 7 〉	통과 (0.06ms, 30MB)
// 테스트 8 〉	통과 (0.04ms, 30.2MB)
// 테스트 9 〉	통과 (0.05ms, 30.1MB)
// 테스트 10 〉	통과 (0.07ms, 30.3MB)
// 테스트 11 〉	통과 (0.06ms, 30.1MB)
// 테스트 12 〉	통과 (0.06ms, 30MB)
// 테스트 13 〉	통과 (0.06ms, 30.2MB)
// 테스트 14 〉	통과 (0.06ms, 30.1MB)
// 테스트 15 〉	통과 (0.06ms, 30.1MB)
// 테스트 16 〉	통과 (0.04ms, 30.2MB)
// 테스트 17 〉	통과 (0.06ms, 30.2MB)
// 테스트 18 〉	통과 (0.04ms, 29.7MB)
// 테스트 19 〉	통과 (0.11ms, 30.1MB)
// 테스트 20 〉	통과 (0.06ms, 30.1MB)
// 테스트 21 〉	통과 (0.04ms, 30.3MB)

