function solution(arr, divisor) {
    let answer = [];
    let arr2 = arr.map((i) => {if (i % divisor === 0){ return i }})
    let arr3 = arr.filter(i => i % divisor === 0)
    arr3.sort((a, b) => a - b)
    return arr3.length === 0 ? [-1] : arr3;
}

// 문제풀이:
// 이번 문제는 배열에서 규칙(룰)에 맞는 요소만 빼서 배열로 다시 만들어야 하는 문제이다.
// 이 경우 filter라는 함수를 쓰면 매우 수월하다. 

// 처음에 filter란 함수를 모르고 그 동안 많이 봤던 map함수로 코드를 짜봤다. (arr2)
// 문제는 map은 배열의 모든 요소를 return 한다는 점이었다. 
// 즉 map함수는 배열의 모든 요소에 접근해서 규칙에 따라 그 요소를 변경할 때 쓰는 용도이다.a

// 따라서 map함수를 접고, filter라는 함수로
// 룰에 맞는 요소만 배열로 남기고, 이를 sort해서 return하면 된다.

// 마지막에 배열의 길이가 0이면 [-1] 배열을 리턴하고, 아니면 그대로 리턴하도록 짰다. 


// 느낀점:
// 오... 얼마 안되었지만
// map, filter 함수의 용도를 뭔가 알아가는 느낌이 처음으로 들어 기분이 좋았다!
// 아마도 더 생각했으면 코드를 1-2줄로도 충분히 짤 수 있을것 같았다! 

// 사용 함수 및 기능:
// map : 배열에서 규칙에 따라 요소를 바꿔 배열로 만듬 (처음과 return해서 나온 배열의 길이 동일) => 2차원배열에서 큰 힘을 발휘할 듯 싶다! 저번 문제처럼
// filter : 배열에서 규칙에 맞는 요소만 빼서 배열로 만들 때 사용
// sort : sort((a,b) => a-b) 오름차순!
// 삼항연산자 : return 마지막 문